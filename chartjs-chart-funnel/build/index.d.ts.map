{"version":3,"file":"index.d.ts","sources":["../src/elements/TrapezoidElement.ts","../src/controllers/FunnelController.ts","../src/color.ts"],"sourcesContent":["import {\n  BarElement,\n  CommonElementOptions,\n  BarOptions,\n  ScriptableAndArrayOptions,\n  ChartType,\n  CommonHoverOptions,\n  ScriptableContext,\n} from 'chart.js';\n\nexport interface TrapezoidElementOptions extends CommonElementOptions, Record<string, unknown> {\n  /**\n   * Width of the border\n   * @default 0\n   */\n  borderWidth: number;\n  /**\n   * which side of the bar to shrink: top, right, middle, none\n   * @default top\n   */\n  shrinkAnchor: 'middle' | 'top' | 'bottom' | 'none';\n  /**\n   * fraction (0-1) of the bar that shrinks shrink. 1 all of the bar, 0 none\n   * @default 1\n   */\n  shrinkFraction: number;\n}\n\nexport interface TrapezoidElementProps {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  base: number;\n  horizontal: boolean;\n}\n\nfunction inBetween(v: number, min: number, max: number, delta = 10e-6) {\n  return v >= Math.min(min, max) - delta && v <= Math.max(min, max) + delta;\n}\n\nfunction transpose(m: { horizontal: boolean; left: number; top: number; right: number; bottom: number }) {\n  return {\n    left: m.top,\n    right: m.bottom,\n    top: m.left,\n    bottom: m.right,\n    horizontal: !m.horizontal,\n  };\n}\n\n// need to make it a bar element for proper data label support\nexport class TrapezoidElement extends BarElement {\n  // <TrapezoidElementProps, TrapezoidElementOptions> implements VisualElement {\n  static readonly id = 'trapezoid';\n\n  /**\n   * @hidden\n   */\n  declare options: BarOptions & TrapezoidElementOptions;\n\n  /**\n   * @hidden\n   */\n  static readonly defaults = /* #__PURE__ */ {\n    ...BarElement.defaults,\n    shrinkAnchor: 'top',\n    shrinkFraction: 1,\n  };\n\n  /**\n   * @hidden\n   */\n  static readonly defaultRoutes = /* #__PURE__ */ BarElement.defaultRoutes;\n\n  /**\n   * @hidden\n   */\n  align: 'left' | 'right' | 'center' = 'center';\n\n  /**\n   * @hidden\n   */\n  next: TrapezoidElement | undefined = undefined;\n\n  /**\n   * @hidden\n   */\n  previous: TrapezoidElement | undefined = undefined;\n\n  private getBounds(useFinalPosition = false) {\n    // x ... center not start\n    const { x, y, base, width, height, horizontal } = this.getProps(\n      ['x', 'y', 'base', 'width', 'height', 'horizontal'],\n      useFinalPosition\n    );\n    if (horizontal) {\n      const w = Math.abs(x - base);\n      const left = base - (this.align !== 'left' ? w : 0);\n      const right = base + (this.align !== 'right' ? w : 0);\n      const half = height / 2;\n      const top = y - half;\n      const bottom = y + half;\n      return { left, top, right, bottom, horizontal };\n    } else {\n      const h = Math.abs(y - base);\n      const half = width / 2;\n      const left = x - half;\n      const right = x + half;\n      const top = base - (this.align !== 'right' ? h : 0);\n      const bottom = base + (this.align !== 'left' ? h : 0);\n      return { left, top, right, bottom, horizontal };\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  inRange(mouseX: number | null, mouseY: number | null, useFinalPosition: boolean) {\n    const bb = this.getBounds(useFinalPosition);\n    const inX = mouseX == null || inBetween(mouseX, bb.left, bb.right);\n    const inY = mouseY == null || inBetween(mouseY, bb.top, bb.bottom);\n    return inX && inY;\n  }\n\n  /**\n   * @hidden\n   */\n  inXRange(mouseX: number, useFinalPosition: boolean) {\n    return this.inRange(mouseX, null, useFinalPosition);\n  }\n\n  /**\n   * @hidden\n   */\n  inYRange(mouseY: number, useFinalPosition: boolean) {\n    return this.inRange(null, mouseY, useFinalPosition);\n  }\n\n  /**\n   * @hidden\n   */\n  getCenterPoint(useFinalPosition: boolean) {\n    const { x, y, base, horizontal } = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    const r = {\n      center: {\n        x: horizontal ? base : x,\n        y: horizontal ? y : base,\n      },\n      left: {\n        x: horizontal ? (base + x) / 2 : x,\n        y: horizontal ? y : (base + y) / 2,\n      },\n      right: {\n        x: horizontal ? base - (x - base) / 2 : x,\n        y: horizontal ? y : base - (y + base) / 2,\n      },\n    }[this.align];\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n  tooltipPosition(useFinalPosition: boolean): { x: number; y: number } {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  /**\n   * @hidden\n   */\n  getRange(axis: string) {\n    const { width, height } = this.getProps(['width', 'height']);\n    // const factor;\n    return axis === 'x' ? width : height;\n  }\n\n  private computeWayPoints(useFinalPosition = false): [number, number][] {\n    let dir = this.options.shrinkAnchor;\n    let shrinkFraction = Math.max(Math.min(this.options.shrinkFraction, 1), 0);\n\n    if (shrinkFraction === 0) {\n      dir = 'none';\n      shrinkFraction = 1;\n    }\n\n    let bounds = this.getBounds(useFinalPosition);\n    const hor = bounds.horizontal;\n    let nextBounds = this.next && (dir === 'top' || dir === 'middle') ? this.next.getBounds(useFinalPosition) : bounds;\n    let prevBounds =\n      this.previous && (dir === 'bottom' || dir === 'middle') ? this.previous.getBounds(useFinalPosition) : bounds;\n\n    if (!hor) {\n      bounds = transpose(bounds);\n      nextBounds = transpose(nextBounds);\n      prevBounds = transpose(prevBounds);\n    }\n\n    const hi = Math.floor((bounds.bottom - bounds.top) * (1 - shrinkFraction));\n    const hiRest = Math.floor((bounds.bottom - bounds.top - hi) / 2);\n\n    const points: [number, number][] = [];\n    const rPoints: [number, number][] = [];\n    if (dir === 'none' || dir === 'top') {\n      points.push([bounds.left, bounds.top], [bounds.right, bounds.top]);\n    } else {\n      let pFraction = 1;\n      if (dir === 'middle') {\n        const pHiRest = Math.floor((prevBounds.bottom - prevBounds.top) * shrinkFraction * 0.5);\n        pFraction = hiRest / (pHiRest + hiRest);\n      }\n      points.push(\n        [bounds.left + (prevBounds.left - bounds.left) * pFraction, bounds.top],\n        [bounds.right + (prevBounds.right - bounds.right) * pFraction, bounds.top]\n      );\n    }\n\n    if (dir === 'middle') {\n      points.push([bounds.right, bounds.top + hiRest]);\n      points.push([bounds.right, bounds.bottom - hiRest]);\n      rPoints.push([bounds.left, bounds.top + hiRest]);\n      rPoints.push([bounds.left, bounds.bottom - hiRest]);\n    } else if (dir === 'top' && shrinkFraction < 1) {\n      points.push([bounds.right, bounds.top + hi]);\n      rPoints.push([bounds.left, bounds.top + hi]);\n    } else if (dir === 'bottom' && shrinkFraction < 1) {\n      points.push([bounds.right, bounds.bottom - hi]);\n      rPoints.push([bounds.left, bounds.bottom - hi]);\n    }\n\n    if (dir === 'none' || dir === 'bottom') {\n      points.push([bounds.right, bounds.bottom], [bounds.left, bounds.bottom]);\n    } else {\n      let nFraction = 1;\n      if (dir === 'middle') {\n        const nHiRest = Math.floor((nextBounds.bottom - nextBounds.top) * shrinkFraction * 0.5);\n        nFraction = hiRest / (nHiRest + hiRest);\n      }\n      points.push(\n        [bounds.right + (nextBounds.right - bounds.right) * nFraction, bounds.bottom],\n        [bounds.left + (nextBounds.left - bounds.left) * nFraction, bounds.bottom]\n      );\n    }\n\n    points.push(...rPoints.reverse());\n\n    if (!hor) {\n      return points.map(([x, y]) => [y, x]);\n    }\n    return points;\n  }\n\n  /**\n   * @hidden\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    const { options } = this;\n    ctx.save();\n    ctx.beginPath();\n    const points = this.computeWayPoints();\n    ctx.moveTo(points[0][0], points[0][1]);\n    for (const p of points.slice(1)) {\n      ctx.lineTo(p[0], p[1]);\n    }\n    if (options.backgroundColor) {\n      ctx.fillStyle = options.backgroundColor;\n      ctx.fill();\n    }\n    if (options.borderColor) {\n      ctx.strokeStyle = options.borderColor;\n      ctx.lineWidth = options.borderWidth as number;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n}\n\ndeclare module 'chart.js' {\n  export interface ElementOptionsByType<TType extends ChartType> {\n    trapezoid: ScriptableAndArrayOptions<TrapezoidElementOptions & CommonHoverOptions, ScriptableContext<TType>>;\n  }\n}\n","import {\n  Chart,\n  ChartItem,\n  ScriptableAndArrayOptions,\n  ControllerDatasetOptions,\n  CommonHoverOptions,\n  UpdateMode,\n  ChartConfiguration,\n  Scale,\n  ScriptableContext,\n  CategoryScale,\n  BarController,\n  CoreChartOptions,\n  CartesianScaleTypeRegistry,\n  LinearScale,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { pickForegroundColorToBackgroundColor, blues } from '../color';\nimport { TrapezoidElement, TrapezoidElementOptions } from '../elements';\nimport patchController from './patchController';\n\nexport interface FunnelChartOptions {\n  /**\n   * alignment of the elements one of center, left, right\n   * @default center\n   */\n  align: 'center' | 'left' | 'right';\n}\n\nexport class FunnelController extends BarController {\n  /**\n   * @hidden\n   */\n  declare options: FunnelChartOptions;\n\n  static readonly id: string = 'funnel';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    BarController.defaults,\n    {\n      dataElementType: TrapezoidElement.id,\n      barPercentage: 1,\n      align: 'center',\n      categoryPercentage: 0.98,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [\n    (BarController as any).overrides,\n    {\n      plugins: {\n        legend: {\n          display: false,\n        },\n        colors: {\n          enabled: false,\n        },\n        datalabels: {\n          anchor: 'start',\n          // align: 'start',\n          textAlign: 'center',\n          font: {\n            size: 20,\n          },\n          color: (context: {\n            chart: Chart<'funnel'>;\n            dataset: Chart['data']['datasets'][0];\n            dataIndex: number;\n            datasetIndex: number;\n          }) => {\n            // auto pick color based on background color\n            const bgColor = context.chart.getDatasetMeta(context.datasetIndex).data[context.dataIndex].options\n              .backgroundColor as string;\n            return pickForegroundColorToBackgroundColor(bgColor, Chart.defaults.color as string, '#ffffff');\n          },\n          formatter: (value: number, context: { chart: Chart<'funnel'>; dataIndex: number }) => {\n            const label = context.chart.data.labels?.[context.dataIndex] ?? '';\n            return `${label}\\n${(value * 100).toLocaleString()}%`;\n          },\n        },\n      },\n      scales: {\n        _index_: {\n          display: false,\n          padding: 10,\n          grid: {\n            display: false,\n          },\n        },\n        _value_: {\n          display: false,\n          beginAtZero: false,\n          grace: 0,\n          grid: {\n            display: false,\n          },\n        },\n      },\n      elements: {\n        trapezoid: {\n          backgroundColor(context: ScriptableContext<'funnel'>) {\n            const nData = context.chart.data.datasets[context.datasetIndex].data.length;\n            return blues(context.dataIndex, nData);\n          },\n        },\n      },\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  getMinMax(scale: Scale, canStack?: boolean | undefined): { min: number; max: number } {\n    const { max } = super.getMinMax(scale, canStack);\n    const r = {\n      // fake mirroring the scale\n      center: { min: -max, max },\n      left: { min: 0, max },\n      right: { min: -max, max: 0 },\n    }[this.options.align];\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n  update(mode: UpdateMode): void {\n    super.update(mode);\n    const meta = this._cachedMeta;\n    // create a link\n    const elements = (meta.data || []) as unknown as TrapezoidElement[];\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].align = this.options.align;\n      elements[i].next = elements[i + 1];\n      elements[i].previous = elements[i - 1];\n    }\n  }\n}\n\nexport interface FunnelControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    ScriptableAndArrayOptions<TrapezoidElementOptions, ScriptableContext<'funnel'>>,\n    ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'funnel'>> {}\n\ndeclare module 'chart.js' {\n  interface ChartTypeRegistry {\n    funnel: {\n      chartOptions: FunnelChartOptions & CoreChartOptions<'funnel'>;\n      datasetOptions: FunnelControllerDatasetOptions;\n      defaultDataPoint: number;\n      metaExtensions: Record<string, never>;\n      parsedDataType: { x: number; y: number };\n      scales: keyof CartesianScaleTypeRegistry;\n    };\n  }\n}\n\nexport class FunnelChart<DATA extends unknown[] = number[], LABEL = string> extends Chart<'funnel', DATA, LABEL> {\n  static id = FunnelController.id as 'funnel';\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'funnel', DATA, LABEL>, 'type'>) {\n    super(item, patchController('funnel', config, FunnelController, TrapezoidElement, [CategoryScale, LinearScale]));\n  }\n}\n","import chroma from 'chroma-js';\n\nexport function pickForegroundColorToBackgroundColor(\n  color: string,\n  blackColor: string = '#000000',\n  whiteColor: string = '#ffffff'\n): string {\n  return chroma(color).luminance() > 0.5 ? blackColor : whiteColor;\n}\n\nexport function blues(i: number, n: number): string {\n  return chroma\n    .scale('Blues')(i / (n - 1))\n    .hex();\n}\n"],"names":[],"mappings":";;;;;;;;;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;ACpCO;AACA;;;"}